---
title: "Fit European model"
author: "Amy Davis", 
        "Soria Delva"
date: "2024-10-20"
output: html_document
---
### 3. Create European SDM

##### 0. Load packages
```{r load libraries,echo=FALSE,message=FALSE}
options("rgdal_show_exportToProj4_warnings"="none")
library(sf)
library(here)
library(ggplot2)
library(RColorBrewer)
```

```{r install or load right version of caretEnsemble}
# Define the desired version
desired_version <- "2.0.3"

# Check if caretEnsemble is installed
if ("caretEnsemble" %in% rownames(installed.packages())) {
  # Get the current version of caretEnsemble
  current_version <- packageVersion("caretEnsemble")
  # Compare current version with the desired version
  if (as.character(current_version) != desired_version) {
    # Uninstall the current version if it's not the desired version
    remove.packages("caretEnsemble")
    # Install the specific version
   devtools::install_github("zachmayer/caretEnsemble@2.0.3")
    # Load 
    library(caretEnsemble)
  } else {
    library(caretEnsemble)
  }
  
} else {
  # If caretEnsemble is not installed, install the specific version
 devtools::install_github("zachmayer/caretEnsemble@2.0.3")
  # Load 
  library(caretEnsemble)
}
```

##### 1. Source helper functions
```{r source helpers, echo=FALSE}
source("./src/helper_functions.R")
```

### Create European subset
```{r subset_eu_occurrences,echo=FALSE}
euboundary<-st_read(here("./data/external/GIS/Europe/EUROPE.shp")) 
eu_occ<-st_join(euboundary, global.occ.sf)%>%
  select(decimalLatitude, decimalLongitude, species)%>%
  filter(!is.na(decimalLatitude))%>%
  st_drop_geometry()

ggplot()+ 
  geom_sf(data = euboundary,  colour = "black", fill = NA)+
  geom_point(data=eu_occ, aes(x=decimalLongitude, y= decimalLatitude),  fill="green", shape = 22, colour = "black", size=3)+
  labs(x="Longitude", y="Latitude")+
  theme_bw()
```

### Create RasterStack of European climate variables from RMI

# stack climate data 
```{r stack all_euclimate_preds}  
rmiclimrasters <- list.files((here("./data/external/climate/rmi_corrected")),pattern='tif',full.names = T) 
rmiclimrasters #shows all available climate data
rmiclimpreds<-rast(rmiclimrasters) #includes all available climate data
```


### Transform eu occurrence dataset with unique presences back to an sf dataframe 

```{r eu_occurences_to_spatialDF}
euocc <- st_as_sf(eu_occ, coords=c("decimalLongitude", "decimalLatitude"), crs= 4326, remove=FALSE)  %>%
  st_transform(crs=st_crs(rmiclimpreds))%>%
  st_drop_geometry()%>%
  select(decimalLongitude, decimalLatitude, species)
```

### Clip bias grid to European extent

```{r clip_biasgrid}
ecoregions_eu<-crop(rast(biasgrid_sub),euboundary)
biasgrid_eu <- project(ecoregions_eu, rmiclimpreds) #reproject the ecoregions raster to match the spatial properties of rmi climpreds

#Plot
ggplot()+ 
 geom_sf(data = euboundary,  colour = "black", fill = NA)+
  geom_spatraster(data=biasgrid_eu)+
  scale_fill_continuous(na.value = "transparent",low = "blue", high = "orange")+
 labs(x="Longitude", y="Latitude")+
  theme_bw()
```

### Mask areas of high habitat suitability from global climate model
```{r mask highSuitability}
#m<-global_model >.5 
#Create a mask of the global_model rasterlayer, containing only areas that are predicted to contain occurrences
m<-global_model >= global.ens.thresh$predicted
#Mask the global_model layer with this occurrence layer (i.e., convert all areas where occurrences are predicted to NA)
global_mask<-mask(global_model,m,maskvalue=TRUE)
global_masked_proj<-project(global_mask,biasgrid_eu)
plot(global_masked_proj)

```

### Combine areas of low predicted habitat suitability with bias grid to exclude low sampled areas and areas of high suitability

```{r create_pseudoSamplingArea}
pseudoSamplingArea<-mask(global_masked_proj,biasgrid_eu)
plot(pseudoSamplingArea)
```

### Randomly locate pseudo absences within "pseudoSamplingArea" 
```{r create_eu_pseudoAbsences}

# set number of pseudoabsences equal to the number of presences
numb.eu.pseudoabs<-nrow(euocc)

# takes 10 draws of random pseudoabsences, returns as dataframes and names them X1-X10
setlist<-seq(1,10,1)
set.seed(120)
pseudoabs_pts<-lapply(setlist,function(x) as.data.frame(randomPoints(raster(pseudoSamplingArea), numb.eu.pseudoabs , euocc, ext=NULL, extf=1.1, excludep=TRUE, prob=FALSE,cellnumbers=FALSE, tryf=50, warn=2, lonlatCorrection=TRUE)))
names(pseudoabs_pts)<-paste0("X",setlist)
```

###  Prepare occurrence (presence-pseudoabsence) datasets for modelling

```{r create eu_presence_absence datasets}
# extract data from predictors for absences
pseudoabs_pts1<-lapply(pseudoabs_pts, function(x) raster::extract(rmiclimpreds,x))

# add absence indicator
add.occ<-function(x,y){
occ<-rep(y,nrow(x))
cbind(x,occ)
}

pseudoabs_pts2<-lapply(pseudoabs_pts1, function(x) add.occ(x,0))

# extract eu presences and add presence indicator 
presence<-as.data.frame(euocc1@coords)
names(presence)<- c("x","y")
presence1<-raster::extract(rmiclimpreds,presence)
occ<-rep(1,nrow(presence1))
presence1<-cbind(presence1,occ)

# join each pseudoabsence set with presences 
eu_presabs.pts<-lapply(pseudoabs_pts2, function(x) rbind(x,presence1))
eu_presabs.coord<-lapply(pseudoabs_pts, function(x) rbind(x,presence))
```


### Identify highly correlated climate predictors from training data

```{r identifyCorrelated_RMI_Preds}
# convert eu data to dataframe
eu_presabs.pts.df<-lapply(eu_presabs.pts,function(x) as.data.frame(x))

# find attributes that are highly corrected 
highlyCorrelated_climate <-lapply(names(eu_presabs.pts.df),function(x) findCorrelation(cor(eu_presabs.pts.df[[x]],use = 'complete.obs'), cutoff=0.7,exact=TRUE,names=TRUE))

highlyCorrelated_climate 
eupreds<-as.data.frame(highlyCorrelated_climate[1])
kable(eupreds) %>%
kable_styling(bootstrap_options = c("striped"))
```

### Reomve highly correlated climate predictors from training data
```{r removeCorrelated_RMI_Preds}
drop_climate<-highlyCorrelated_climate[[1]]
rmiclimpreds_uncor<-dropLayer(rmiclimpreds,drop_climate)
```

### Add habitat and anthropogenic predictors

```{r add_habitatPreds,echo=FALSE}
habitat<-list.files((here("./data/external/habitat/landcover")),pattern='tif',full.names = T)
habitat_stack<-stack(habitat)
fullstack<-stack(rmiclimpreds_uncor,habitat_stack) #combine uncorrelated climate variable selected earlier with habitat



# clip fullstack to belgium extent (if using another country, replace with country boundary shapefile)
country<-shapefile(here("./data/external/GIS/belgium_boundary.shp"))
fullstack_crop<-crop(fullstack,country)
fullstack_be<-mask(fullstack_crop,country)

occ.full.data <-lapply(eu_presabs.coord, function(x) raster::extract(fullstack,x))
```


### Identify highly correlated predictors from the habitat/anthropogenic/climate stack (full stack)
```{r identifyCorrelatedPreds_from_fullStack}

# find attributes that are highly correlated
highlyCorrelated_full <-lapply(names(occ.full.data),function(x) findCorrelation(cor(occ.full.data[[x]],use = 'complete.obs'), cutoff=0.7,exact=TRUE,names=TRUE))
highlyCorrelated_vec<-unlist(highlyCorrelated_full)
eupreds1<-as.data.frame(highlyCorrelated_vec)
kable(eupreds1) %>%
kable_styling(bootstrap_options = c("striped"))
```
### Remove highly correlated predictors from full stack 
```{r removeCorrelatedPreds_from_fullStack}
occ.full.data<-sapply(names(occ.full.data),function (x) occ.full.data[[x]][,!(colnames(occ.full.data[[x]]) %in% highlyCorrelated_vec)],simplify=FALSE)
```


###  Identify and remove near zero variance predictors
```{r removeLowVarPreds_from_fullStack}
# identify low variance predictors
nzv_preds<-lapply(names(occ.full.data),function(x) nearZeroVar(occ.full.data[[x]],names=TRUE))
nzv_preds
nzv_preds.vec<-unique(unlist(nzv_preds))
nzv_preds.vec
# remove near zero variance predictors. They don't contribute to the model.
occ.full.data<-sapply(names(occ.full.data),function (x) occ.full.data[[x]][,!(colnames(occ.full.data[[x]]) %in% nzv_preds.vec)],simplify=FALSE)
```

### Build models with climate and habitat data

```{r run_euModel,message=FALSE,warning=FALSE}

# prepare data for modeling

occ.full.data.df<-lapply(occ.full.data, function(x) as.data.frame(x))

occ.full.data.df<- sapply(names(occ.full.data.df), function (x) cbind(occ.full.data.df[[x]],occ=eu_presabs.pts.df[[x]]$occ, deparse.level=0),simplify=FALSE)



factorVars<-function(df,var){
df[,c(var)]<-as.factor(df[,c(var)])
levels(df[,c(var)])<-c("absent","present")
df[,c(var)]<-relevel(df[,c(var)], ref = "present")
return(df)
}


occ.full.data.factor<-sapply(names(occ.full.data.df), function (x) factorVars(occ.full.data.df[[x]], "occ"),simplify=FALSE)
occ.full.data.forCaret<-sapply(names(occ.full.data.factor), function (x) replace(occ.full.data.factor[[x]], is.na(occ.full.data.factor[[x]]),0),simplify=FALSE)



# uncomment 2nd control options for  LOOCV (leave one out cross validation, which is aka as "jacknife" ) which should be used when occurrences are smaller than n=10 for each predictor in the model)

#control<-trainControl(method="LOOCV",savePredictions="final", preProc=c("center","scale"),classProbs=TRUE)
control <- trainControl(method="cv",number=4,savePredictions="final", preProc=c("center","scale"),classProbs=TRUE)
mylist<-list(
  glm =caretModelSpec(method = "glm",maxit=100),
  gbm= caretModelSpec(method = "gbm"),
  rf = caretModelSpec(method = "rf", importance = TRUE),
  earth= caretModelSpec(method = "earth"))

# set.seed(167)
 eu_models<-sapply(names(occ.full.data.forCaret), function(x) model_train_habitat <- caretList(
   occ~temprang + maxtemp + annpvarrecip_eea + corine_perWetland, data= occ.full.data.forCaret[[x]],
   trControl=control,
    tuneList=mylist), simplify=FALSE)

```
### Display model evaluation statistics

```{r show_euModel_accuracy}
EU_ModelResults1<-sapply(names(eu_models), function(x) resamples(eu_models[[x]]),simplify=FALSE)
Results.summary<-sapply(names(EU_ModelResults1), function(x) summary(EU_ModelResults1[[x]]),simplify=FALSE)
Results.summary
```

```{r show_euModel_correlation}
Model.cor<-sapply(names(eu_models), function(x) modelCor(resamples(eu_models[[x]])),simplify=FALSE)
Model.cor
```

### Create ensemble model 

```{r run eu_ensemble}

set.seed(458)

#hideoutput<-capture.output(
set.seed(458)
lm_ens_hab<-sapply(names(eu_models), function (x) caretEnsemble(eu_models[[x]], trControl=trainControl(method="cv",                                                               number=10,savePredictions= "final",classProbs = TRUE)),simplify=FALSE)

```


#### PDF export function 

```{r export_toPDF,echo=FALSE}
exportPDF<-function(rst,taxonkey,taxonName,nameextension,is.diff="FALSE"){
  filename=file.path(pdfOutput,paste("be_",taxonkey, "_",nameextension,sep=""))
  pdf(file=filename,width=10,height=8,paper="a4r")
  par(bty="n")#to turn off box around plot
  ifelse(is.diff=="TRUE", brks<-seq(-1, 1, by=0.2), brks <- seq(0, 1, by=0.1)) 
  nb <- length(brks)-1 
  pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
  cols<-pal(nb)
  maintitle<-paste(taxonName,taxonkey,"_",nameextension, sep= " ")
  plot(rst, breaks=brks, col=cols,main=maintitle, lab.breaks=brks,axes=FALSE)
  dev.off() 
} 
```

#### PNG export function 
```{r export_toPNG,echo=FALSE}
exportPNG<-function(rst,taxonkey,taxonName,nameextension,is.diff="FALSE"){
  filename=file.path(pdfOutput,paste("be_",taxonkey, "_",nameextension,sep=""))
  png(file=filename)
  par(bty="n")#to turn off box around plot
  ifelse(is.diff=="TRUE", brks<-seq(-1, 1, by=0.25), brks <- seq(0, 1, by=0.1)) 
  nb <- length(brks)-1 
  pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')))
  cols<-pal(nb)
  maintitle<-paste(taxonName,taxonkey,"_",nameextension, sep= " ")
  plot(rst, breaks=brks, col=cols,main=maintitle, lab.breaks=brks,axes=FALSE)
  dev.off() 
} 
```

###  Use EU level ensemble models (each using a separate pseudoabsence draw) to predict at European level 

```{r ensModel_predictEU,results= "hide", cache=TRUE}
 ens_pred_hab_eu1<-sapply(names(lm_ens_hab), function(x) raster::predict(fullstack,lm_ens_hab[[x]],type="prob"),simplify=FALSE)
 
```