---
title: "Fit European model"
author: "Amy Davis", 
        "Soria Delva"
date: "2024-10-20"
output: html_document
---
### 3. Create European SDM

##### To do: Specify project and country for which you aim to make predictions
```{r specify project}
#specify project name
projectname<-"Test_Frédérique"
```

```{r specify country}
#If you'd like to predict for another country, change the shapefile
country<-shapefile(here("./data/external/GIS/Belgium/belgium_boundary.shp"))
country_ext<-terra::ext(country) 
country_vector <- vect(country) #Convert country to a SpatVector that can be used for masking
```

##### 0. Load packages
```{r load libraries,echo=FALSE,message=FALSE}
options("rgdal_show_exportToProj4_warnings"="none")
library(sf)
library(here)
library(ggplot2)
library(RColorBrewer)
library(terra)
```

```{r install or load right version of caretEnsemble}
# Define the desired version
desired_version <- "2.0.3"

# Check if caretEnsemble is installed
if ("caretEnsemble" %in% rownames(installed.packages())) {
  # Get the current version of caretEnsemble
  current_version <- packageVersion("caretEnsemble")
  # Compare current version with the desired version
  if (as.character(current_version) != desired_version) {
    # Uninstall the current version if it's not the desired version
    remove.packages("caretEnsemble")
    # Install the specific version
   devtools::install_github("zachmayer/caretEnsemble@2.0.3")
    # Load 
    library(caretEnsemble)
  } else {
    library(caretEnsemble)
  }
  
} else {
  # If caretEnsemble is not installed, install the specific version
 devtools::install_github("zachmayer/caretEnsemble@2.0.3")
  # Load 
  library(caretEnsemble)
  rm(current_version, desired_version)
}
```

##### 1. Source helper functions
```{r source helpers, echo=FALSE}
source("./src/helper_functions.R")
```

#### Load shapefiles that will be used
```{r Load shapefiles}
euboundary<-st_read(here("./data/external/GIS/Europe/EUROPE.shp")) 
```

#### Create RasterStack of European climate variables from RMI
```{r stack all_euclimate_preds}  
rmiclimrasters <- list.files((here("./data/external/climate/rmi_corrected")),pattern='tif',full.names = T) 
rmiclimrasters #shows all available climate data
rmiclimpreds<-rast(rmiclimrasters) #includes all available climate data
```

#### Load species that should be modelled
```{r Load species}
taxa_info<-read.csv2(paste0("./data/projects/",projectname,"/",projectname,"_taxa_info.csv"))
accepted_taxonkeys<-taxa_info%>%
  pull(accepted_taxonkeys)%>%
  unique()
```

### Start loop

```{r}
for(key in accepted_taxonkeys){
  #Extract species name
  species<-taxa_info%>%
    filter(accepted_taxonkeys==key)%>%
    pull(scientificName)%>%
    unique()
  
  #Extract first two words of species name
  first_two_words <- sub("^(\\w+)\\s+(\\w+).*", "\\1_\\2", species)
  
  #Define taxonkey
  taxonkey<- key
  
  #Read in globalmodels object that was stored as part of  script 02_fit_global_model
  globalmodels<-qread( paste0("./data/projects/",projectname,"/",first_two_words,"_",taxonkey,"/Global_model_",first_two_words,"_",taxonkey,".qs"
  ))
  
  #Read in different data objects stored in globalmodels
  global.occ.sf<-globalmodels$occurrences
  biasgrid_sub<-globalmodels$biasgrid
  global_model<-unwrap(globalmodels$global_model_predictions)
  model_accuracy<-globalmodels$model_accuracy
```

### Create European subset
```{r subset_eu_occurrences,echo=FALSE}
eu_occ<-st_join(euboundary, global.occ.sf)%>%
  select(decimalLatitude, decimalLongitude, species)%>%
  filter(!is.na(decimalLatitude))%>%
  st_drop_geometry()

```

```{r Plot european subset, eval=FALSE}
ggplot()+ 
  geom_sf(data = euboundary,  colour = "black", fill = NA)+
  geom_point(data=eu_occ, aes(x=decimalLongitude, y= decimalLatitude),  fill="green", shape = 22, colour = "black", size=3)+
  labs(x="Longitude", y="Latitude")+
  theme_bw()
```

### Transform eu occurrence dataset with unique presences back to an sf dataframe 

```{r eu_occurences_to_spatialDF}
euocc <- st_as_sf(eu_occ, coords=c("decimalLongitude", "decimalLatitude"), crs= 4326, remove=FALSE)  %>%
  st_transform(crs=st_crs(rmiclimpreds))%>%
   st_coordinates()
```

### Clip bias grid to European extent

```{r clip_biasgrid}
ecoregions_eu<-crop(rast(biasgrid_sub),euboundary)
biasgrid_eu <- project(ecoregions_eu, rmiclimpreds) #reproject the ecoregions raster to match the spatial properties of rmi climpreds
```

```{r Plot biasgrid eu, eval=FALSE}
ggplot()+ 
 geom_sf(data = euboundary,  colour = "black", fill = NA)+
  geom_spatraster(data=biasgrid_eu)+
  scale_fill_continuous(na.value = "transparent",low = "blue", high = "orange")+
 labs(x="Longitude", y="Latitude")+
  theme_bw()
```

### Mask areas of high habitat suitability from global climate model
```{r mask highSuitability}
#Create a mask of the global_model rasterlayer, containing only areas that are predicted to contain occurrences
m<- global_model >= model_accuracy$threshold

#Mask the global_model layer with this occurrence layer (i.e., convert all areas where occurrences are predicted to NA)
global_mask<-mask(global_model,m,maskvalue=TRUE)
global_masked_proj<-project(global_mask,biasgrid_eu)

```


```{r Restrict pseudoSamplingArea to environmental layers}
#This was not included in Amy's code but mask the pseudoSamplingArea with one of the environmental layers to make sure no pseudoabsences are generated outside the environmental layers
global_masked_proj<-terra::mask(global_masked_proj, rmiclimpreds[[1]]) 
```

```{r Plot global_masked_proj, eval=FALSE}
brks <- seq(0, 1, by=0.1) 
  nb <- length(brks)-1 
# Generate Viridis palette
viridis_palette <- viridis(nb)

ggplot()+ 
  geom_spatraster(data=global_masked_proj)+
  geom_sf(data = euboundary,  colour = "black", fill = NA)+
   scale_fill_gradientn(colors = viridis_palette, breaks = brks, labels = brks , na.value = NA) +
 labs(x="Longitude", y="Latitude")+
  theme_bw()
```

### Combine areas of low predicted habitat suitability with bias grid to exclude low sampled areas and areas of high suitability

```{r create_pseudoSamplingArea}
pseudoSamplingArea<-mask(global_masked_proj,biasgrid_eu)
plot(pseudoSamplingArea)
```

### Randomly locate pseudo absences within "pseudoSamplingArea" 
```{r create_eu_pseudoAbsences}

# set number of pseudoabsences equal to the number of presences
numb.eu.pseudoabs<-nrow(euocc)

# takes 10 draws of random pseudoabsences, returns as dataframes and names them X1-X10
setlist<-seq(1,10,1)
set.seed(120)
pseudoabs_pts<-lapply(setlist,function(x) as.data.frame(randomPoints(raster(pseudoSamplingArea), numb.eu.pseudoabs , euocc, ext=NULL, extf=1.1, excludep=TRUE, prob=FALSE,cellnumbers=FALSE, tryf=50, warn=2, lonlatCorrection=TRUE)))
names(pseudoabs_pts)<-paste0("X",setlist)
```

###  Prepare occurrence (presence-pseudoabsence) datasets for modelling

```{r create eu_presence_absence datasets}
# extract data from predictors for absences
pseudoabs_pts1<-lapply(pseudoabs_pts, function(x) terra::extract(rmiclimpreds,x))

# add absence indicator
add.occ<-function(x,y){
occ<-rep(y,nrow(x))
cbind(x,occ)
}

pseudoabs_pts2<-lapply(pseudoabs_pts1, function(x) add.occ(x,0))

# extract eu presences and add presence indicator 
presence<-as.data.frame(euocc)
names(presence)<- c("x","y")
presence1<-terra::extract(rmiclimpreds,presence)
occ<-rep(1,nrow(presence1))
presence1<-cbind(presence1,occ)

# join each pseudoabsence set with presences 
eu_presabs.pts<-lapply(pseudoabs_pts2, function(x) rbind(x,presence1))
eu_presabs.coord<-lapply(pseudoabs_pts, function(x) rbind(x,presence))
```


### Identify highly correlated climate predictors from training data

```{r identifyCorrelated_RMI_Preds}
# convert eu data to dataframe
eu_presabs.pts.df<-lapply(eu_presabs.pts,function(x) as.data.frame(x))

# find attributes that are highly corrected 
highlyCorrelated_climate <-lapply(names(eu_presabs.pts.df),function(x) findCorrelation(cor(eu_presabs.pts.df[[x]],use = 'complete.obs'), cutoff=0.7,exact=TRUE,names=TRUE))

highlyCorrelated_climate 
eupreds<-as.data.frame(highlyCorrelated_climate[1])
kable(eupreds) %>%
  kable_styling(bootstrap_options = c("striped"))
```

### Remove highly correlated climate predictors from training data
```{r removeCorrelated_RMI_Preds}
drop_climate<-highlyCorrelated_climate[[1]]
keep_layers <- !(names(rmiclimpreds) %in% drop_climate)
rmiclimpreds_uncor <- subset(rmiclimpreds, keep_layers)

```

### Add habitat and anthropogenic predictors

```{r add_habitatPreds,echo=FALSE}
habitat<-list.files((here("./data/external/habitat")),pattern='tif',full.names = T)
habitat_stack<-rast(habitat[c(1:5,7)]) #Distance to water has another extent
fullstack<-c(rmiclimpreds_uncor,habitat_stack) #combine uncorrelated climate variable selected earlier with habitat



# clip fullstack to belgium extent (if using another country, replace with country boundary shapefile)
country<-shapefile(here("./data/external/GIS/Belgium/belgium_boundary.shp"))
country_ext<-terra::ext(country) 
country_vector <- vect(country) #Convert country to a SpatVector that can be used for masking
fullstack_crop<-crop(fullstack,country_ext)
fullstack_be<-mask(fullstack_crop,country_vector)

occ.full.data <-lapply(eu_presabs.coord, function(x) raster::extract(fullstack,x))
```


### Identify highly correlated predictors from the habitat/anthropogenic/climate stack (full stack)
```{r identifyCorrelatedPreds_from_fullStack}

# find attributes that are highly correlated
highlyCorrelated_full <-lapply(names(occ.full.data),function(x)
  findCorrelation(cor(occ.full.data[[x]],use = 'complete.obs'), cutoff=0.7,exact=TRUE,names=TRUE))

highlyCorrelated_vec<-unlist(highlyCorrelated_full)
eupreds1<-as.data.frame(highlyCorrelated_vec)
kable(eupreds1) %>%
kable_styling(bootstrap_options = c("striped"))
```

### Remove highly correlated predictors from occ.full.data
```{r removeCorrelatedPreds_from_occ.full.data}
occ.full.data<-sapply(names(occ.full.data),function (x) occ.full.data[[x]][,!(colnames(occ.full.data[[x]]) %in% highlyCorrelated_vec)],simplify=FALSE)
```

### Remove highly correlated predictors from fullstack
```{r removeCorrelated_RMI_Preds}
keep_layers <- !(names(fullstack) %in% highlyCorrelated_vec)
fullstack <- subset(fullstack, keep_layers)

```

###  Identify and remove near zero variance predictors
```{r removeLowVarPreds_from_fullStack}
# identify low variance predictors
nzv_preds<-lapply(names(occ.full.data),function(x) caret::nearZeroVar(occ.full.data[[x]],names=TRUE))
nzv_preds
nzv_preds.vec<-unique(unlist(nzv_preds))
nzv_preds.vec
# remove near zero variance predictors. They don't contribute to the model.
occ.full.data<-sapply(names(occ.full.data),function (x) occ.full.data[[x]][,!(colnames(occ.full.data[[x]]) %in% nzv_preds.vec)],simplify=FALSE)
```


### Build models with climate and habitat data

```{r run_euModel,message=FALSE,warning=FALSE}

# prepare data for modeling

occ.full.data.df<-lapply(occ.full.data, function(x) as.data.frame(x))

occ.full.data.df<- sapply(names(occ.full.data.df), function (x) cbind(occ.full.data.df[[x]],occ=eu_presabs.pts.df[[x]]$occ, deparse.level=0),simplify=FALSE)



factorVars<-function(df,var){
df[,c(var)]<-as.factor(df[,c(var)])
levels(df[,c(var)])<-c("absent","present")
df[,c(var)]<-relevel(df[,c(var)], ref = "present")
return(df)
}

#Recode factor levels of column 'occ' to absent (0) and present(1), and set present as the reference level
occ.full.data.factor<-sapply(names(occ.full.data.df), function (x) factorVars(occ.full.data.df[[x]], "occ"),simplify=FALSE)

#Replace NA values with 0 in all columns 
occ.full.data.forCaret<-sapply(names(occ.full.data.factor), function (x) replace(occ.full.data.factor[[x]], is.na(occ.full.data.factor[[x]]),0),simplify=FALSE)



# uncomment 2nd control options for  LOOCV (leave one out cross validation, which is aka as "jacknife" ) which should be used when occurrences are smaller than n=10 for each predictor in the model)

#control<-trainControl(method="LOOCV",savePredictions="final", preProc=c("center","scale"),classProbs=TRUE)

if(nrow(presence)<10){
  control<-trainControl(method="LOOCV",
                        savePredictions="final", 
                        preProc=c("center","scale"),
                        classProbs=TRUE) 
}else{
  control <- trainControl(method="cv",
                          number=4,
                          savePredictions="final", 
                          preProc=c("center","scale"),
                          classProbs=TRUE)
}

mylist<-list(
  glm =caretModelSpec(method = "glm",maxit=100),
  gbm= caretModelSpec(method = "gbm"),
  rf = caretModelSpec(method = "rf", importance = TRUE),
  earth= caretModelSpec(method = "earth"))

#Remove ID column of each dataframe or it will be used as a predictor variable
occ.full.data.forCaret <- lapply(occ.full.data.forCaret, function(df) {
   df[ , !names(df) %in% "ID"]  # Keep all columns except "ID"
})

# set.seed(167)
 eu_models<-sapply(names(occ.full.data.forCaret), function(x) model_train_habitat <- caretList(
   occ~., 
   data= occ.full.data.forCaret[[x]],
   trControl=control,
   tuneList=mylist), 
   simplify=FALSE)

```
### Display model evaluation statistics

```{r show_euModel_accuracy}
EU_ModelResults1<-sapply(names(eu_models), function(x) resamples(eu_models[[x]]),simplify=FALSE)
Results.summary<-sapply(names(EU_ModelResults1), function(x) summary(EU_ModelResults1[[x]]),simplify=FALSE)
Results.summary
```

```{r show_euModel_correlation}
Model.cor<-sapply(names(eu_models), function(x) modelCor(resamples(eu_models[[x]])),simplify=FALSE)
Model.cor
```


### Create ensemble model 

```{r run eu_ensemble}

set.seed(458)

#hideoutput<-capture.output(
set.seed(458)
lm_ens_hab<-sapply(names(eu_models), function (x) caretEnsemble(eu_models[[x]], trControl=trainControl(method="cv",                                                               number=10,savePredictions= "final",classProbs = TRUE)),simplify=FALSE)

```


###  Use EU level ensemble models (each using a separate pseudoabsence draw) to predict at European level 

```{r ensModel_predictEU,results= "hide", cache=TRUE}
system.time({
 ens_pred_hab_eu1<-sapply(names(lm_ens_hab), function(x) terra::predict(fullstack,lm_ens_hab[[x]],type="prob", na.rm = TRUE),simplify=FALSE)
})
```

### Use EU level ensemble models to predict for Belgium only  

```{r ensModel_predictBE,results="hide"}

# creates  country level rasters using the European level models
system.time({
ens_pred_hab_be<-sapply(names(lm_ens_hab), function(x) terra::predict(fullstack_be,lm_ens_hab[[x]],type="prob", na.rm=TRUE),simplify=FALSE)
})


# export rasters as GeoTiffs
#lapply(names(ens_pred_hab_be), function(x) writeRaster(ens_pred_hab_be[[x]], filename=file.path(rasterOutput,paste(x,"_",taxonkey,"_hist.tif",sep="")),  format="GTiff",overwrite=TRUE))
```

###  Evaluate the performance of each the EU level ensemble models based on results from CV

```{r findThreshold,echo=FALSE}
# 1.indentify threshold where sensitivity=specifity
thresholds<-sapply(names(lm_ens_hab), function(x) findThresh(lm_ens_hab[[x]]$ens_model$pred),simplify=FALSE)
```

# 2. Using thresholds identified for each model in the previous step, assess performance of each model
```{r accuracyMetrics,echo=FALSE}
# accuracy measures
thresholds.df<-sapply(names(thresholds), function(x) accuracyStats(lm_ens_hab[[x]]$ens_model$pred,thresholds[[x]]$predicted),simplify=FALSE)
thresholds.comb<-do.call(rbind,thresholds.df)
kable(thresholds.comb,digits=2)
```

### plot the best EU level ensemble model
```{r Plot_ensModel_eu}
# specify best model below
bestmodelname<-rownames(thresholds.comb)[which.max(thresholds.comb$PCC)]
bestModel<-lm_ens_hab[[bestmodelname]]

euocc1<-st_as_sf(as.data.frame(euocc), coords=c("X","Y"),crs=st_crs(rmiclimpreds))


#Plot
brks <- seq(0, 1, by=0.1)
nb <- length(brks) - 1
viridis_palette <- viridis(nb)

ggplot() + 
  geom_spatraster(data = ens_pred_hab_eu1[[bestmodelname]]) +
  scale_fill_gradientn(colors = viridis_palette, 
                       breaks = brks, 
                       labels = brks, 
                       na.value = NA) +
  geom_sf(data = euocc1, color = "black", fill = "red", 
          size = 1.5, shape = 21) +
  theme_bw() +
  labs(fill = "Suitability")

#Plot Belgian model
brks <- seq(0, 1, by=0.1)
nb <- length(brks) - 1
viridis_palette <- viridis(nb)

ggplot() + 
  geom_spatraster(data = ens_pred_hab_be[[bestmodelname]]) +
  scale_fill_gradientn(colors = viridis_palette, 
                       breaks = brks, 
                       labels = brks, 
                       na.value = NA) +
  theme_bw() +
  labs(fill = "Suitability")
```